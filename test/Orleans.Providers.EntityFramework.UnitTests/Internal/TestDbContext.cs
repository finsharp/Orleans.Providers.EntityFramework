using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Update;
using Orleans.Providers.EntityFramework.UnitTests.Models;

namespace Orleans.Providers.EntityFramework.UnitTests.Internal;

public class TestDbContext : DbContext
{
    private static readonly Random Random = new(234);

    public TestDbContext(DbContextOptions options)
        : base(options)
    {
    }

    public DbSet<EntityWithGuidKey> GuidKeyEntities { get; set; }
    public DbSet<EntityWithGuidCompoundKey> GuidCompoundKeyEntities { get; set; }
    public DbSet<EntityWithIntegerKey> IntegerKeyEntities { get; set; }
    public DbSet<EntityWithIntegerCompoundKey> IntegerCompoundKeyEntities { get; set; }
    public DbSet<EntityWithStringKey> StringKeyEntities { get; set; }

    public DbSet<EntityWithIntegerKeyWithEtag> ETagEntities { get; set; }

    public DbSet<ConfiguredEntityWithCustomGuidKey> ConfiguredEntities { get; set; }
    public DbSet<UnconfiguredEntityWithCustomGuidKey> UnconfiguredEntities { get; set; }

    public DbSet<InvalidConfiguredEntityWithCustomGuidKey> InvalidEntities { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity<EntityWithGuidKey>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithGuidCompoundKey>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithIntegerKey>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithIntegerCompoundKey>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithStringKey>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithIntegerKeyWithEtag>()
            .Property(e => e.IsPersisted)
            .HasConversion(
                isPersisted => true,
                value => true);

        builder.Entity<EntityWithIntegerKeyWithEtag>()
            .Property(e => e.ETag)

            //A timestamp/rowversion is a property for which a new value is automatically generated by the database every time a row is inserted or updated.  see https://docs.microsoft.com/en-us/ef/core/modeling/concurrency?tabs=fluent-api#timestamprowversion
            //duplicate! Model had set this "public byte[] ETag { get; set; }= BitConverter.GetBytes(Random.Next());" 

            //.HasConversion<byte[]>(
            //    value => BitConverter.GetBytes(Random.Next()),
            //    storedValue => storedValue
            //)
            //.IsConcurrencyToken();
            .IsRowVersion();

        builder.Entity<EntityWithGuidCompoundKey>()
            .HasKey(e => new
            {
                e.Id,
                e.KeyExt
            });
        builder.Entity<EntityWithIntegerCompoundKey>()
            .HasKey(e => new
            {
                e.Id,
                e.KeyExt
            });

        builder.Entity<ConfiguredEntityWithCustomGuidKey>()
            .HasKey(e => new
            {
                e.CustomKey,
                e.CustomKeyExt
            });

        builder.Entity<UnconfiguredEntityWithCustomGuidKey>()
            .HasKey(e => new
            {
                e.CustomKey,
                e.CustomKeyExt
            });

        builder.Entity<InvalidConfiguredEntityWithCustomGuidKey>()
            .HasKey(e => new
            {
                e.CustomKey,
                e.CustomKeyExt
            });
    }

    public override int SaveChanges()
    {
        MockConcurrencyChecks();
        return base.SaveChanges();
    }

    public override Task<int> SaveChangesAsync(
        CancellationToken cancellationToken = new())
    {
        MockConcurrencyChecks();
        return base.SaveChangesAsync(cancellationToken);
    }

    private void MockConcurrencyChecks()
    {
        // Check etags as the in-memory storage doesn't
        foreach (var entitiy in ETagEntities.Local)
        {
            var entry = Entry(entitiy);

            if (entry.State != EntityState.Modified)
                continue;

            var storedEntity = ETagEntities.AsNoTracking()
                .Single(e => e.Id == entitiy.Id);

            if (!storedEntity.ETag.SequenceEqual(entitiy.ETag))
                throw new DbUpdateConcurrencyException("ETag violation",
                    entry.GetInfrastructure().StateManager.Entries.Select(
                        e => (IUpdateEntry) e).ToList());

            entitiy.ETag = BitConverter.GetBytes(Random.Next());
        }
    }
}